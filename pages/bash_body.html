<html>
<head>
<title>Introduction To Bash Shell Scripting (2004.11.06)</title>
</head>
<body>
<h1>Introduction To Bash Shell Scripting</h1>
<h2>References</h2>
<ul>
<li>Learning the Bash Shell, Cameron Newham & Bill Rosenblatt (O'Reilly & Associates, Inc)
<li>Linux in a Nutshell,  Jessica Perry Hekman (O'Reilly & Associates, Inc)
<li>The UNIX Programming Environment, Brian W Kernigham & Rob Pike (Prenice Hall)
<li>Unix Power Tools, Jerry Peek, Tim O'Relly, & Mike Lookides (O'Reilly & Associates,Inc)
<li><a href="http://www.tldp.org/LDP/abs/html">Advance Bash Scripting Guide</a> : http://www.tldp.org/LDP/abs/html
<br>Appendix B has some good Reference Cards
</ul>
<h2>Review</h2>
<ul>
<li><h3>Getting Help</h3>
<ul><pre>
<li>man                Get off information about commands
<li>man -k             Get off information via keyword
<li>info               Read info documents
<li>help               Show help on shell built-in commands
<li>command --help     Help on command .i.e.  cp --help   Will give help on cp
<li>bash -c "help"     Short help on bash
<li>bash -c "help set" Short help on bash options
</pre></ul>
<li><h3>Special Characters</h3>
<ul><pre>
<li>Space             Argument separator
<li>\                 Quote a single character
                  A \ followed by a carriage return extend the current line
<li>'                 Quote rext with spaces in it i.e. 'Hello world'
<li>$'                Quote allows string expansion, backslash-escaped characters
<li>"                 Quote rext, expands variables and command substitution
<li>`                 Command substitution i.e. echo "The date is `date`"
<li>$                 Denote a shell variable
<li>#                 Comments the rest of the line
<li>;                 Commands separator
<li>(commands)        Run multiple commands in a subshell
<li>Control-C         Interrupt a command
<li>Control-D         Sends End of File from terminal
<li>Control-U         Erases the entire command line
<li>Control-\         Is a stronger terminate than Control-c
<li>Control-Z          Suspend process
</pre></ul>
<li><h3>Redirection, Pipes and Filters</h3>
<ul><pre>
<li>-          Standard In for some commands
<li>0          Standard In	
<li>1          Standard Out
<li>2          Standard Error
<li>>2&1       Redirect standard error to standard out
<li>&>         Redirect standard error & standard out
<li><          Redirect input
<li>>          Redirect output
<li>>>         Concatenate output to file
<li><<         Here Is File for scripts
<li>|          Pipe
<li>tee        Command write to file and standard out
<li>tee -a FILE #Allow appending to FILE
<li>xargs      Build command from standardin
</pre></ul>
<li><h3>Wildcards</h3>
<ul><pre>
<li>*          Wildcard for any character(s)
<li>?          Wildcard for single character
<li>[set]      Wildcard for character in set
<li>[^set ]    Wildcard for not the character  in the set
<li>[!set ]    Wildcard for not the character  in the set
<li>{ab,dc}    Wildcard for alternate between commas
<li>All wildcard work with existing files
<li>Only {} alternate work to create files

</pre></ul>
<li><h3>Process Control</h3>
<ul><pre>
<li>(<i><b>command1</b></i>; <i><b>command</b></i>)  Run command1, then command2 in subshell
<li><i><b>command1&&command</b></i>    Run command1, then command2 if command1 successes
<li><i><b>command1||command</b></i>    Run command1, then command2 if command1 fails
</pre></ul>
<li><h3>Regular Expressions</h3>
<ul><pre><li>Definition: Text pattern of text character and meta characters
<li>Some Meta characters<ul>
<li>Escape character  \
<li>Single Character Meta characters<ul>
<li>.         Matches any one character
<li>[...]     Matches any one character in a set
<li>[^...]    Matches any one character not in the set
</ul>
<li>Quantifiers<ul>>
<li>*       Matches the previous character zero or more times
<li>\{n\}   Matches the previous character n times
<li>\{n,m\} Matches the previous character at least n & at most m
<li>\{n,\}  Matches the previous character n or more times</ul>
<li>Anchors<ul>
<li>^       Matching at the start the line
<li>$       Matching at the end of line</ul>
<lI>Grouping       \( \)
</pre></ul>
<li>Commands that use regular expressions<ul><pre>
<li>awk        Pattern scanning and text processing language
<li>ed         Line-oriented text editor
<li>egrep      extended grep
<li>emacs      Emacs full screen text editor
<li>ex         Line-oriented text editor
<li>expr       Command evaluates an expression
<li>fgrep      Grep from patterns in a file
<li>gawk       GNU pattern scanning and processing language
<li>grep       Searches file for pattern (also see fgrep & egrep)
<ul>grep [OPTIONS] PATTERN [INPUT-FILE...]
<li>-E        same as egrep
<li>-c        Count
<li>-e        pattern (for multiple pattern on line)
<li>-f        same as fgrep
<li>-i        Ignore case
<li>-l        Only list files containing pattern
<li>-q        Quit (No output, only Return Code)
<li>-v        Invert sense mode</ul>
<li>perl      Perl scripting
<li>python    Python scripting
<li>sed        Applies a set of user-specified editing command to a file
<ul>sed [OPTIONS] 'sed_command' [INPUT_FILE...]
<li>-n        Suppress automatic printing
<li>-e        expression - sed_command
<li>substitute other_text for some_text
sed 's/some_text/other_text/g' FILE > NEWFILE 
<li>multiple changes
sed -e 's@abc@def@g' -e 's@xyz@mno@g' FILE
<li>print out line with faq in them
sed -n '/faq/p' FILE
<li>change Page ### to (Page ###) at end of line
sed 's/Page [0-9]+$/(&)/' file      # & replace the match
<li>delete blank lines
sed '/^[ \t]*$/d</ul>
<li>tcl        Tool command language
<li>vi         Full screen text editor
</pre></ul>
</ul></ul>
<h2>Shell Variables</h2>
<ul>
<li><h3>Built-in Shell Variables</h3>
<ul><pre>
<li>CDPATH     Path of shortcuts for cd (like PATH)
<li>COLUMNS   Numbers of columns on the display
<li>EDITOR     Path for editor
<li>HISTSIZE   Number of commands in command history (default 500)
<li>IFS        Input Field Separator
<li>LINES      Numbers of lines on the display
<li>OFS        Output Field Separator
<li>SECONDS    Seconds that this shell is running
<li>SHELLOPT   Colon separate list of shell options
</pre></ul>
<li><h3>Environment Variables</h3>
<ul><pre>
<li>export var Will make a variable an environment variable
<li>HOME       User's home directory
<li>LOGNAME    User's name
<li>MAIL       Name of user's mailbox
<li>PATH       List of directories to be search by the shell
<br>           to find programs whose names are type as commands
<li>PS1        String that is used by the shell prompt
<li>PWD        Name of current directory
<li>SHELL      Name of current shell
<li>TERM       The kind of terminal being used
<li>Environment variable are global to shell and subshells
</pre></ul>
<li><h3>User Variables</h3>
<ul><pre>
<li>Can be either upper or lower case
<li>var=value  Define a variable
<li>var=""     Define a variable as null
<li>local var  Define a variable local to its scope
</pre></ul>
<li><h3>Positional Variables</h3>
<ul><pre>
<li>$0        Name of function or script being called
<li>$1 ... $9 Replace by arguments to shell or function
<li>${n}      Replace by n-th arguments to shell or function
          required if number of argument is over 9
</pre></ul>
<li><h3>Special Variables</h3>
<ul><pre>
<li>$?        Exit status or return code of last command
<li>$#        Number of arguments
<li>$@        Argument 1 thru n with Input Field Separator
<li>$*        "$1" $2" ... $n 
<li>$!        Process id of last background process
<li>$$        Process id of shell running this script
<li>$-        The current shell flags
</pre></ul></ul>
<h2>Some Command Useful With Scripts</h2>
<ul><pre>
<li>basename   Strip directory and option suffix
<li>declare    Built-in command declares variable
<li>dirname    Strip non-directory part
<li>echo       Built-in command display message to standard out
<li>echo -n    Built-in command display message to standard out without newline
<li>echo -e    Builtin Command display message to standout with escape sequences
<li>enable     Built-in command to enable/disable (-n) built-in commands
<li>env        Built-in command displays environment variables
<li>eval       Built-in command evaluate arguments before executing results
<li>exec       Built-in command runs command as the shell process
<li>exit       Built-in command exits shell
<li>expr       Evaluates an expression and output its value
<li>false      Built-in command always return false condition
<li>local      Built-in command make variable local
<li>read       Built-in command reads data into variable from standard in
<li>seq        Print a sequence of numbers<ul>
<li>       seq [OPTION]... LAST
<li>       seq [OPTION]... FIRST LAST
<li>       seq [OPTION]... FIRST INCREMENT LAST
<li>       -w   equalize width by padding with leading zeroes</ul>
<li>sleep      Command causes execution to stop for a
           specified number of seconds
<li>test       Built-in command tests for various conditions, such as
           existence of a file, useful for controlling
           conditional script execution
<li>time       Built-in command times commands
<li>times      Print accumulated user and system times.
<li>true       Built-in command always return true condition
<li>type       Built-in command show what word is
<li>wait       wait for the completion of background
           processing; is used to ensure that critical
           processing is complete before proceeding in a script
</pre></ul>
<h2>Making Scripts Colorful</h2>
<ul><pre>
<li>tput sgr0     #Reset text attributes to normal without clearing screen
<li>Escape sequence to change colors 
  #\e[${forground};${background}m
  example white on black sequence is \e[37;40m
  #Forground colors  Backgrounfd Color
  black=30;          bgblace=40
  red=31;            bgred=41
  green=32;          bggreen=42
  yellow=33;         bgyellow=43 
  blue=34;           bgblue=44
  magenta=35;        bgmagenta=45
  cyan=36;           bgcyan=46
  white=37;          bgwhite=47
<li>Turn text attribute off \e[0m
<li>Change text attribute bold \e[1m
<li>Change text attribute underline \e[4m
<li>Change text attributer everse \e[7m
</pre></ul>
<h2>Shell Functions and Scripts</h2>
<ul>
<li><h3>Functions</h3>
<ul><pre>
<li>Function must be sourced just like .bashrc
<li>type <i><b>function</b></i> will list the function
<li>function <i><b>functionname</b></i> {
                        shell commands
}

<li><i><b>functionname</b></i> () {
                  shell commands
}
<li>Example - a helpful function
function givehelp { exec $1 --help | more; }
</ul></pre>

<li><h3>Scripts</h3>
<ul><pre>
<li>#!/bin/bash        Script name run script is run if execute bit is set
<li>#!/bin/bash -x     As above, but script lines are displayed
<li>bash -x script     As above
<li>/usr/bin/env bash  Use the environment bash for the script
</pre></ul>
<li><h3>Script Debugging options</h3><pre><ul>
set -o OPTION  Command line  Action     
<li>set -o noexec  sh -n        Don't run command, just check for syntax
<li>set -o verbose sh -v        Echo commands before running them
<li>set -o xtrace  sh -x        Echo commands after running them
<li>set +o OPTION               Turns OPTION off
</ul></pre>

</pre></ul></ul>
<h2>Operation With Variables</h2>
<ul>
<li><h3>Variable Usage</h3>
<ul><pre>
<li>$var      Value of variable var
<li>"$var"    Is null if variable is undefined
          avoids some shell syntax errors if variable is undefined
<li>${var}    Value of variable var
          avoids confusion when concatenating with text
<li>${#var}   Gives the length of the string contained in var
<li>${var:FIRST:N} Extract string from var starting at FIRST position
           and continuing for N-1 characters.  Note FIRST starts at 0.
</pre></ul>
<li><h3>Passing an variable to a program or script</h3>
<ul><pre>
<li>echo $var | command
</pre></ul>
<li><h3>Arrays</h3>
<ul><pre>
<li>declare -a name         Declare an array
<li>name[index]=value       Just assigning a value defines it
<li>Index starts at zero
<li>No maximum limit
<li>Need not be contiguous
</pre></ul>
<li><h3>Setting Variable From Execution of Command</h3>
<ul><pre>
<li>var=`command`           var is set to output of command
<li>var=$(command)          same as above
</pre></ul>
<li><h3>Arithmetic Operation</h3>
<ul><pre>
<li>$(( expression ))       Almost the same as 'expr expression'
<li>$[ expression ]         Same as above
<li>( expression )          Groups expression within $(( ... ))
<li>expr expression         Note must quote *
</pre></ul>
<li><h3>Arithmetic operator</h3>
<ul><pre>
<li>+     add
<li>-     substract
<li>*     multiply
<li>/     divide
<li>%     remainder
<li>#     number conversion (Only in bash not expr)
</pre></ul>
</pre></ul>
<li><h3>Test Operation</h3>
<ul><pre>
<li>[ -option arg ]         Same as 'test -option arg
<li>[[ -option arg ]]       Same as 'test -option arg
<li>[ arg1 -option arg2 ]   Same as 'test arg1 -option arg2'
<li>[[ arg1 -option arg2 ]] Same as 'test arg1 -option arg2'
<li>See test command for test complete list of options
<ul>
<li>string1 = string2       String 1 equals string 2
<li>string1 !=string2       String 1 not equals string 2
<li>-n string               String is not zero length
<li>-z string               String is zero length
<li>-d FILE                 File is a directory
<li>-e FILE                 File exists
<li>-f FILE                 File exists and is a regular file
<li>-r FILE                 File exists and is readable
<li>-s FILE                 File exists and has length greater than zero
<li>-w FILE                 File exists and is writable
<li>-x FILE                 File exists and is executable
<li>num1 -eq num2           Number 1 equals number 2
<li>num1 -ne num2           Number 1 not equals number 2
<li>num1 -lt num2           Number 1 less than number 2
<li>num1 -le num2           Number 1 less than or equals number 2
<li>num1 -gt num2           Number 1 greater than number 2
<li>num1 -ge num2           Number 1 greater than or equals number 2</ul>
</pre></ul>
<li><h3>String Operation</h3>
<ul><pre>
<li>${varname:-word}        Return var if exists and is not null, else word
<li>${varname:+word}        Return word if var exists and is not null, else null
<li>${varname:?mess}        Return var if exists and is not null, else
                        display mess and return from script with error
</pre></ul>
<li><h3>Pattern Operations</h3>
<ul><pre>
<li>${variable#pattern}     If the pattern matches the beginning of the
                        variable value, delete the shortest part  that
                        matches and return the rest
<li>${variable##pattern}    If the pattern matches the beginning the of
                        variable value, delete the longest part  that 
                        matches and return the rest
<li>${variable%pattern}     If the pattern matches the end of the variable
                        value, delete the shortest part  that matches and
                        return the rest
<li>${variable%%pattern}    If the pattern matches the end of the variable
                        value, delete the longest part  that matches and
                        return the rest
</pre></ul></ul>
<h2>The handy 'expr'</h2>
<ul><pre>
<li>expr <i><b>string : regrep</b></i>          Anchored pattern match
<li>expr match <i><b>string pattern</b></i>     Same as above
<li>expr substr <i><b>string pos {len]</b></i>  Substring beginning at pos of length len
<li>expr length <i><b>string</b></i>            Length of string
</pre></ul>
<h2>Flow Control</h2>
<ul>
<li><h3>if - general information</h3>
<ul><pre>
if <i><b>command</b></i>               Test return code of command
if <i><b>command1</b></i> && <i><b>command2</b></i>  Test return code of command1 and command2
if <i><b>command1</b></i> || <i><b>command2</b></i>  Test return code of command1 or command2
<i><b>command</b></i> can be condition i.e. [ $# -eq 0 ]</ul>
</pre>
<li><h3>if/then/else or if/then/elif..</h3>
<ul><pre>
if <i><b>condition</b></i>
  then <i><b>statements...</b><i>
  [else <i><b>statements...</b></i>]
fi

if <i><b>condition</b></i>
  then <i><b>statements...</b></i>
  [elif <i><b>condition</b></i>
    then <i><b>statements...]</b></i>
    [else] <i><b>statements...</b></i>]
fi
</pre></ul>
<li><h3>return from Function</h3>
<ul><pre>
return [ <i><b>numeric expression or variable</b></i> ]  This is the return code
</pre></ul>
<li><h3>for</h3>
<ul><pre>
for <i><b>name</b></i> [ in <i><b>list</b></i> ] do
  <i><b>statements</b></i>
done

for  <i><b>variable</b></i> = <i><b>start</b></i> to <i><b>end</b></i> do
  <i><b>statements</b></i>
done
</pre></ul>
<li><h3>while/until</h3>
<ul><pre>
while <i><b>condition</b></i> do
  <i><b>statements</b></i>
done

until <i><b>condition</b></i> do
  <i><b>statements</b></i>
done
</pre></ul></ul>
<li><h3>break/continue</h3>
<ul><pre>
<li>break [<i><b>n</b></i>]      Break out of loop & select
<li>continue [<i><b>n</b></i>]   Continue next iteration of loop
</pre></ul>
<li><h3>case</h3>
<ul><pre>
case <i><b>expression</b></i> in<i><b>
  pattern1[|pattern11] } statements ;;
  pattern2[|pattern21] } statements ;;
  ...</b></i>
esac
</pre></ul>
<h2>User Interfaces</h2>
<li><h3>select</h3>
<ul><pre>
select <i><b>name</b></i> [in <i><b>list</b></i>] do
  <i><b>statements</b></i> that can use <i><b>$name</b></i>
done
<li>Generate a menu of each item in the <i><b>list</b></i> formatted with
a number for each choice
<li>Prompt the user for the number
<li>Store the selected choice in <i><b>name</b></i>.  The number is stored in REPLY
<li>execute the statements in the do
<li>Repeat the process again
</ul>
</pre></ul>
<h3>Command Line Options</h3>
<ul><pre>
<li>shift      Shift 1st argument form the argument list
<li>getopts    Used to process command line options
<li>OPTIND     Variable contains number of options
<li>OPTARG     Default variable for option
<li>Example
  while getopts ":ab:c" opt; do
    case $opt in
      a) process_option_a;;
      b) process_option_b
         $OPTARG is the option's argument;;
      c) process_option_c;;
    esac
  done
  shift $(($OPTIND - 1))
</pre></ul>
<h2>I/O in Scripts</h2>
<ul><pre>
<li>printf        Built-in command for formatted output
<li>read          Built-in command to read one line into variable(s)
  read            #Everything entered goes to REPLY
  read var        #Everything is read into var
  read a b        #Read 1st word in to a and rest into b
  read -t 300 var #Read with 300 second timeout
<li>Example how to use read from $file
  while read <i><b>line</b></i>; do
    <i><b>do_something_with_line</b></i>
  done <<i><b>$file</b></i>
</pre></ul>
<h2>Process Handling</h2>
<ul>
<li><h3>Signals</h3>
<ul><pre>
Name  Number  Control Character
<li>EXIT     0                      Used to trap exiting script
<li>HUP      1                      Logout
<li>INT      2        Control-C
<li>QUIT     3        Control-\
<li>KILL     9  can not be ignored or trapped
<li>TERM    15                      Default kill
<li>TSTP    24        Control-Z
</pre></ul>
<li><h3>Traps</h3>
<ul><pre>
<li>trap "" <i><b>signal-list</b></i>      Ignore signal
<li>trap "<i><b>cmds</b></i>" <i><b>signal-list</b></i>  Execute commands if signal is caught
<li>trap <i><b>signal-list</b></i>         Reset signal to original condition
<li>trap : <i><b>signal-list</b></i>       (undocumented) ignore signal, pass to child
                         Signal are normally not passed to subprocesses
<li>Examples
  trap 'rm tmpfile; exit' 0 1 2 #remove tmpfile on exit, logout, interrupt

  trap "echo 'You hit Control-C'" INT
  while true ; do
    sleep 60
  done
<li>Example parent child process
#!/bin/bash                   #parent
echo parent running
trap 'echo parent exiting; exit' 0
trap :2
child
sleep 1000

#!/bin/bash                    #child
echo child started. pid is $$
trap 'echo child got signal 2; exit' INT
sleep 1000

</pre></ul></ul>
<h2>Examples Useful Scripts or Function</h2>
<ul><pre>

<li>#  Function top5   Example how to set defaults
#  Usage   top5 {n}   #list n processes
function top5 {
  ps -ef | head -${1:-5}
}

<li>#  Function hereis    Example of HERE IS FILE and handling arguments
#  Usage  hereis word1 word2 ...
function hereis {
  for name in "$@"
    do
    cat &lt;&lt;MSG
        This is an example of an HERE IS FILE.
        One argument is ${name}.
        The date is `date`.
MSG
  done
}

<li>#  Function pick    Return selected items by user
#  Usage:           .e.g  var=`pick *`
function pick {
  for name in $@ ; do                  #for each item in argument list
    echo -n "$name (y/n/q)?" >/dev/tty #ask user to select
    read ans                           #read answer from standard in
    case $ans in                       #Check choices
      y*) echo $name;;                 #selected
      q*) break;;                      #skip rest of arguments
      *)  continue;;                   #skip item
    esac
  done
}

<li>#  Function acal   Display a nicer calendar
#  but will accept Alphabetic month
function acal {
  m=""
  case $# in
  0) cal; return;;                #no arguments
  1) m=$1; y=`date +%Y`;;         #1 argument
  2) m=$1; y=$2;;                 #2 arguments
  esac

  case $m in
  Jan*|jan* ) m=1;;
  Feb*|feb* ) m=2;;
  Mar*|mar* ) m=3;;
  Apr*|apr* ) m=4;;
  May|may   } m=5;;
  Jun*|jun* ) m=6;;
  Jul*|jul* ) m=7;;
  Aug*|aug* ) m=8;;
  Sep*|sep* } m=9;;
  Oct*|oct* ) m=10;;
  Nov*|nov* ) m=11;;
  Dec*|dec* ) m=12;;
  [1-9]|1[0-2] ) ;; #numeric month
  *)        ) y=$m; m="";;
  esac
  cal $m $y
}

<li>## Function selectex - Example select
#
function selectex () {
  choices="/bin /usr /home"
  select selection in $choices; do
 if [ $selection ]; then
   ls $selection
   break
  else
    echo 'Invalid selection'
  fi
done
}

<li>#  Function fwhich  Which command in $PATH is executed
#
function fwhich {
  if [[ $# -eq 0 ]] ;
    then cat &lt;&lt; EndOfHelp  1>&2; return 2
               Usage fwhich command   #Example of parsing the $PATH
                  Return 0 - found
                  Return 1 - not found
                  Return 2 - No arguments
EndOfHelp
  fi
  for path in `echo $PATH | sed 's/^:/.:/
                              s/::/.:/g
                              s/:$/:./
                              s/:/ /g'`
  do
    if [[ -x $path/$1 ]] ;  # does executable file exists here?
      then echo $path/$1    # found it
      return 0
    fi
  done
  return 1                  # not found
}

<li># Name:         overwrite   Copy standard input to output after EOF
function overwrite {
  if [[ $# -lt 2 ]] ;
    then echo "Usage:  overwrite file command [args]" 1>&2; return 2
  fi

  file=$1; shift
  new=/tmp/overwrite1$$; old=/tmp/overwrite2$$
  trap 'rm -f $new $old; return 1' 1 2 15  # clean up files
  "$@" > $new
  if [[ $? -eq 0 ]] ;                      # collect output
    then                                   # command completed successfully
      cp $file $old                        # save original file
      trap '' 1 2 15                       # we are committed; ignore signals
      cp $new $file                        # copy new file into file
      rm -f $new $old                      # remove temp files
    else
      echo "overwrite: $1 failed, $file unchanged" 1>$2
      return 1
  fi
}

<li># Name:         zgrep
# Purpose:      caseless grep of gzip files
# Usage:        zgrep text files.gz
#
function zgrep {
 if [ $# -eq 0 ] ; then
   echo "Usage: zgrep grep_text files.gz"
    return 2
 fi
  text=$1
  shift
  while  [ $# -gt 0 ]
    do
       echo $1
       gzip -cd $1 | grep -i $text
       shift
    done
}

<li># Name:         hgrep
# Purpose:      highlighting grep
# Usage:        hgrep pattern files
#
function hgrep {
 if [ $# -lt 2 ] ; then
   echo "Usage: hgrep pattern files"
    return 2
 fi
  pattern=$1;shift
  sep=$'\001'    #note use of $' ' to create control characters
  bold=$'\e[1m'; off=$'\e[0m'
  underline=$'\e[4m'; reverse=$'\e[7m'  #other choices of highlighting
  sed -n "s${sep}${pattern}${sep}${reverse}&${off}${sep}gp" $*
}

</ul>
</pre>
</body></html>




